module.exports = function (RED) {
    function fctdatahttpNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        node.on("input", function (msg) {
            try {
                node.log("接收数据");
                const text = msg.payload.Event;
                node.log(Event);
                //node.log(text);
                if (text == "Barcode") {
                    node.log("输入条码");
                    const result = {};
                    const custom = [];
                    const boards = [];
                    
                    // 直接使用JSON格式的payload
                    const data = msg.payload;
                    
                    // 处理常规字段
                    const reservedKeys = ["Event", "DateTime", "User", "FileName", "BoardName", 
                                        "BoardBarcode", "StartType", "FctFile", "BoardCount",
                                        "LastBarcode", "LastBarcode.Board"];
                    
                    // 增强版板卡正则（支持任意数量）
                    const boardRegex = /^B(\d+)\.(Barcode|Pass)$/i;
                
                    // 先收集所有板卡编号
                    const boardNumbers = new Set();
                    
                    // 第一阶段：收集所有存在的板卡编号
                    Object.keys(data).forEach(key => {
                        if (boardRegex.test(key)) {
                            const match = key.match(boardRegex);
                            boardNumbers.add(parseInt(match[1]));
                        }
                    });
                
                    // 第二阶段：创建有序板卡结构
                    Array.from(boardNumbers)
                        .sort((a, b) => a - b)
                        .forEach(num => {
                            const index = num - 1;
                            boards[index] = {
                                ID: `B${num}`,
                                Barcode: data[`B${num}.Barcode`] || "",
                                Pass: parseInt(data[`B${num}.Pass`]) || 0,
                                data: {}
                            };
                        });
                
                    // 第三阶段：处理其他字段
                    Object.keys(data).forEach(key => {
                        // 处理自定义字段（下划线开头）
                        if (key.startsWith('_')) {
                            custom.push({ [key.slice(1)]: data[key] || "" });
                        }
                        // 处理保留字段
                        else if (reservedKeys.includes(key)) {
                            result[key] = data[key];
                        }
                        // 忽略已处理的板卡字段
                        else if (boardRegex.test(key)) {
                            // 已在第二阶段处理
                        }
                        // 处理其他普通字段
                        else if (!key.startsWith('/') && key !== "") {
                            result[key] = data[key];
                        }
                    });
                
                    // 添加结构化数据
                    result["custom"] = custom;
                    result["boards"] = boards.filter(b => b); // 移除空位
                    
                    // 板卡数量验证（增强版）
                    if (result.BoardCount) {
                        const actualCount = result.boards.length;
                        if (actualCount !== result.BoardCount) {
                            node.error(`板卡数量异常！配置数量：${result.BoardCount}，实际解析：${actualCount}`);
                            // 自动补全缺失板卡
                            if (actualCount < result.BoardCount) {
                                for (let i = actualCount; i < result.BoardCount; i++) {
                                    result.boards.push({
                                        ID: `B${i+1}`,
                                        Barcode: "",
                                        Pass: 0,
                                        data: {}
                                    });
                                }
                                node.warn(`已自动补全缺失的${result.BoardCount - actualCount}个板卡`);
                            }
                        }
                    }
                
                    msg.payload = result;
                    node.send([msg, null, null, null]);
                } else if (text == "TestStart") {
                    node.log("测试开始");
                    const result = {};
                    const custom = [];
                    const boards = [];
                    
                    // 直接处理JSON格式数据
                    const data = msg.payload;
                    
                    // 保留字段列表（根据实际需求扩展）
                    const reservedKeys = ["Event", "DateTime", "User", "FileName", 
                                        "BoardName", "BoardBarcode", "StartType", 
                                        "FctFile", "BoardCount"];
                
                    // 板卡字段正则（支持多位数编号）
                    const boardRegex = /^B(\d+)\.(Barcode|Pass)$/i;
                    const boardNumbers = new Set();
                
                    // 第一阶段：收集所有板卡编号
                    Object.keys(data).forEach(key => {
                        if (boardRegex.test(key)) {
                            const match = key.match(boardRegex);
                            boardNumbers.add(parseInt(match[1]));
                        }
                    });
                
                    // 第二阶段：创建有序板卡结构
                    Array.from(boardNumbers)
                        .sort((a, b) => a - b)
                        .forEach(num => {
                            const index = num - 1;
                            boards[index] = {
                                ID: `B${num}`,
                                Barcode: data[`B${num}.Barcode`] || "",
                                Pass: parseInt(data[`B${num}.Pass`]) || 0,
                                data: {}
                            };
                        });
                
                    // 第三阶段：处理其他字段
                    Object.keys(data).forEach(key => {
                        // 处理自定义字段
                        if (key.startsWith('_')) {
                            custom.push({ 
                                [key.slice(1)]: data[key] || "" 
                            });
                        }
                        // 处理保留字段
                        else if (reservedKeys.includes(key)) {
                            result[key] = data[key];
                        }
                        // 忽略已处理的板卡字段
                        else if (boardRegex.test(key)) {
                            return;
                        }
                        // 处理其他普通字段
                        else if (!key.startsWith('/') && key !== "") {
                            result[key] = data[key];
                        }
                    });
                
                    // 结构化输出
                    result["custom"] = custom;
                    result["boards"] = boards.filter(Boolean);
                
                    // 板卡数量自动补全
                    if (result.BoardCount) {
                        const expected = result.BoardCount;
                        const actual = result.boards.length;
                        
                        if (actual < expected) {
                            for (let i = actual; i < expected; i++) {
                                result.boards.push({
                                    ID: `B${i+1}`,
                                    Barcode: "",
                                    Pass: 0,
                                    data: {}
                                });
                            }
                            node.warn(`自动补全 ${expected - actual} 个缺失板卡`);
                        }
                    }
                
                    msg.payload = result;
                    node.send([null, msg, null, null]);
                }else if (text == "TestDone") {
                    node.log("测试完成");
                    const result = {};
                    const custom = [];
                    const boards = [];
                    
                    // 直接处理JSON数据
                    const data = msg.payload;
                    
                    // 保留字段列表（扩展新增字段）
                    const reservedKeys = ["Event", "DateTime", "User", "FileName", 
                                        "BoardName", "BoardBarcode", "StartType",
                                        "FctFile", "BoardCount", "TestCancel"];
                
                    // 增强板卡正则（支持State等新字段）
                    const boardRegex = /^B(\d+)\.(Barcode|Pass|State)$/i;
                    const boardNumbers = new Set();
                
                    // 第一阶段：收集所有板卡编号和字段
                    Object.keys(data).forEach(key => {
                        if (boardRegex.test(key)) {
                            const match = key.match(boardRegex);
                            boardNumbers.add(parseInt(match[1]));
                        }
                    });
                
                    // 第二阶段：创建完整板卡结构
                    Array.from(boardNumbers)
                        .sort((a, b) => a - b)
                        .forEach(num => {
                            const index = num - 1;
                            boards[index] = {
                                ID: `B${num}`,
                                Barcode: data[`B${num}.Barcode`] || "",
                                Pass: parseInt(data[`B${num}.Pass`]) || 0,
                                State: parseInt(data[`B${num}.State`]) || 0, // 新增状态字段
                                data: {} // 保留扩展字段
                            };
                        });
                
                    // 第三阶段：处理其他字段
                    Object.keys(data).forEach(key => {
                        // 处理自定义字段
                        if (key.startsWith('_')) {
                            custom.push({ 
                                [key.slice(1)]: data[key] || "" 
                            });
                        }
                        // 处理保留字段
                        else if (reservedKeys.includes(key)) {
                            result[key] = data[key];
                        }
                        // 忽略已处理的板卡字段
                        else if (boardRegex.test(key)) {
                            return;
                        }
                        // 处理其他普通字段
                        else if (!key.startsWith('/') && key !== "") {
                            result[key] = data[key];
                        }
                    });
                
                    // 结构化输出
                    result["custom"] = custom;
                    result["boards"] = boards.filter(Boolean);
                
                    // 智能板卡补全（增强版）
                    if (result.BoardCount) {
                        const expected = result.BoardCount;
                        const actual = result.boards.length;
                        
                        // 自动补全缺失板卡
                        if (actual < expected) {
                            for (let i = actual; i < expected; i++) {
                                result.boards.push({
                                    ID: `B${i+1}`,
                                    Barcode: "",
                                    Pass: 0,
                                    State: -1, // 特殊状态表示补全板卡
                                    data: {}
                                });
                            }
                            node.warn(`自动补全 ${expected - actual} 个板卡，状态设为-1`);
                        }
                    }
                
                    msg.payload = result;
                    node.send([null, null, msg, null]);
                } else if (text == "TestResult") {
                    const result = {};
                    const custom = [];
                    const boards = [];
                    const detail = [];
                    const data = msg.payload; // 输入已经是JSON对象

                    // 遍历JSON对象的键值对
                    Object.entries(data).forEach(([key, value]) => {
                        // 处理自定义字段（以_开头）
                        if (key.startsWith('_')) {
                            const newKey = key.slice(1);
                            custom.push({ [newKey]: value || "" });
                        }

                        // 处理板卡数据（Bx.xxx格式）
                        else if (/^B\d+\./.test(key)) {
                            const [boardKey, prop] = key.split('.');
                            const boardIndex = parseInt(boardKey.slice(1)) - 1;

                            // 初始化板卡对象
                            if (!boards[boardIndex]) {
                                boards[boardIndex] = {
                                    ID: `B${boardIndex + 1}`,
                                    Barcode: '',
                                    Pass: 0,
                                    State: 0,
                                    data: {}
                                };
                            }

                            // 填充属性
                            switch (prop) {
                                case 'Barcode':
                                    boards[boardIndex].Barcode = value || "";
                                    break;
                                case 'Pass':
                                    boards[boardIndex].Pass = parseInt(value) || 0;
                                    break;
                                case 'State':
                                    boards[boardIndex].State = parseInt(value) || 0;
                                    break;
                                default:
                                    boards[boardIndex].data[prop] = value;
                            }
                        }

                        // 处理Detail数组
                        else if (key === 'Detail') {
                            if (Array.isArray(value)) {
                                detail.push(...value);
                            } else {
                                detail.push(value);
                            }
                        }

                        // 其他字段存入result
                        else {
                            result[key] = value;
                        }
                    });

                    // 过滤空板卡（根据实际BoardCount）
                    const validBoards = boards.slice(0, data.BoardCount || boards.length);


                    //E:\lsd学习文件\文件资料\PTI-800系列\20210524153758.csv
                    const fs = require('fs-extra');
                    const iconv = require('iconv-lite');
                    //fs.readFile(result.Detail1)
                    let ans = [];

                    //let newDetail1 = result.Detail1.toString();
                    //let thenewDetail1 = newDetail1.replace(/\\\\\\\\/g, '\\\\');

                    let csvAll = '';
                    const newDetail = {};
                    let index = 0
                    for (let key in detail) {
                        if (!(detail[key] in newDetail) && detail[key].endsWith('.csv')) {
                            newDetail[key] = detail[key].replace(/\\\\/g, '\\');;
                            node.log(newDetail[key]);
                        }
                    }
                    node.log("csvAll开始");

                    for (let key in newDetail) {
                        fs.readFile(newDetail[key], function (err, data) {  //判断重复 判断csv结尾的格式
                            index += 1;
                            //node.log(iconv.decode(data, 'gb2312'));
                            csvAll += iconv.decode(data, 'gb2312');
                            node.log('Cur:' + index + ',' + Object.keys(newDetail).length)
                            if (index == Object.keys(newDetail).length) {
                                node.log("csvAll结束");
                                if (csvAll.length > 0) {

                                    node.log("分析csv开始**********");
                                    //if (err) throw err;
                                    //var text = iconv.decode(csvAll, 'gb2312');
                                    const resultLines = csvAll.split('\n').map(line => line.trim().replaceAll('"', ""));
                                    let OpenFailCount = 0;
                                    let ShortFailCount = 0;
                                    let compTestFlag = 0;
                                    let compTestFlagStart = 0;
                                    let functionFlag = 0;
                                    let functionFlagStart = 0;
                                    let datas = {
                                        DateTime: "",
                                        ProgramId: "",
                                        User: "",
                                        DeviceId: "",
                                        FixtureId: "",
                                        LineId: "",
                                        ModelName: "",
                                        FixRetry: "",
                                        BoardId: "",
                                        BarCode: "",
                                        TestStat: "",
                                        OpenTest: "",
                                        ShortTest: "",
                                        CompTest: "",
                                        TestTime: "",
                                        OpenFailCount: { "Count": 0, "Pins": [] },
                                        ShortFailCount: { "Count": 0, "Pins": [] },
                                        componentData: [],
                                        functionData: []
                                    };
                                    resultLines.forEach(line => {
                                        // node.log('\n'); 
                                        const values = line.split(',');
                                        // node.log((values[0]));
                                        if (values[0] == "DateTime") {
                                            datas.DateTime = values[1];
                                            // node.log("DateTime+++++++++++++");
                                        }

                                        if (values[0] == "ProgramId") {
                                            datas.ProgramId = values[1];
                                        }
                                        if (values[0] == "User") {
                                            datas.User = values[1];
                                        }
                                        if (values[0] == "DeviceId") {
                                            datas.DeviceId = values[1];
                                        }
                                        if (values[0] == "FixtureId") {
                                            datas.FixtureId = values[1];
                                        }
                                        if (values[0] == "LineId") {
                                            datas.LineId = values[1];
                                        }
                                        if (values[0] == "ModelName") {
                                            datas.ModelName = values[1];
                                        }
                                        if (values[0] == "FixRetry") {
                                            datas.FixRetry = values[1];
                                        }

                                        if (values[0] == "BoardId") {
                                            datas.BoardId = values[1];
                                        }
                                        if (values[0] == "BarCode") {
                                            datas.BarCode = values[1];
                                        }
                                        if (values[0] == "TestStat") {
                                            datas.TestStat = values[1];
                                        }
                                        if (values[0] == "OpenTest") {
                                            datas.OpenTest = values[1];
                                        }
                                        if (values[0] == "ShortTest") {
                                            datas.ShortTest = values[1];
                                        }
                                        if (values[0] == "CompTest") {
                                            datas.CompTest = values[1];
                                        }
                                        if (values[0] == "TestTime") {
                                            datas.TestTime = values[1];
                                        }
                                        if (OpenFailCount != 0) {
                                            datas.OpenFailCount.Pins.push(values[0]);
                                            OpenFailCount--;
                                        }
                                        if (values[0] == "OpenFailCount") {
                                            datas.OpenFailCount.Count = values[1];
                                            OpenFailCount = values[1];
                                        }
                                        if (ShortFailCount != 0) {
                                            datas.ShortFailCount.Pins.push(values[0]);
                                            ShortFailCount--;
                                        }
                                        if (values[0] == "ShortFailCount") {
                                            datas.ShortFailCount.Count = values[1];
                                            ShortFailCount = values[1];
                                        }
                                        if (values[0] == null && values[0] == "" || line == "") {
                                            compTestFlagStart = 0;
                                            compTestFlag = 0;
                                            functionFlag = 0;
                                            functionFlagStart = 0;
                                        }

                                        if (values[0] == "LogEnd") {
                                            node.log("结束**********");
                                            boards.forEach(one => {
                                                if (one.ID == datas.BoardId) {
                                                    one.data = datas;
                                                }
                                            });
                                            OpenFailCount = 0;
                                            ShortFailCount = 0;
                                            compTestFlag = 0;
                                            compTestFlagStart = 0;
                                            functionFlag = 0;
                                            functionFlagStart = 0;
                                            datas = {
                                                DateTime: "",
                                                ProgramId: "",
                                                User: "",
                                                DeviceId: "",
                                                FixtureId: "",
                                                LineId: "",
                                                ModelName: "",
                                                FixRetry: "",
                                                BoardId: "",
                                                BarCode: "",
                                                TestStat: "",
                                                OpenTest: "",
                                                ShortTest: "",
                                                CompTest: "",
                                                TestTime: "",
                                                OpenFailCount: { "Count": 0, "Pins": [] },
                                                ShortFailCount: { "Count": 0, "Pins": [] },
                                                componentData: [],
                                                functionData: []
                                            };
                                        }


                                        if (compTestFlag == 1 && compTestFlagStart == 1 && values[0] != null && values[0] != "") {
                                            let stepCompData = {
                                                STEP: values[0],
                                                BX: values[1],
                                                LC: values[2],
                                                Flag: values[3],
                                                Device: values[4],
                                                STDval: values[5],
                                                ACTval: values[6],
                                                plusPercent: values[7],
                                                minusPercent: values[8],
                                                MD: values[9],
                                                RG: values[10],
                                                TM: values[11],
                                                A: values[12],
                                                B: values[13],
                                                G1: values[14],
                                                G2: values[15],
                                                G3: values[16],
                                                G4: values[17],
                                                G5: values[18],
                                                TestVal: values[19],
                                                DevPercent: values[20],
                                                Result: values[21],
                                            };
                                            datas.componentData.push(stepCompData);
                                        }
                                        if (functionFlag == 1 && functionFlagStart == 1 && values[0] != null && values[0] != "") {
                                            let stepFunctionData = {
                                                STEP: values[0],
                                                BX: values[1],
                                                Descrip: values[2],
                                                Test: values[3],
                                                Std:values[4],
                                                minusPercent: values[5],
                                                plusPercent: values[6],
                                                Result: values[7],
                                                Info: values[8],
                                            };
                                            datas.functionData.push(stepFunctionData);
                                        }
                                        if (values[0] == "CompTest:" || compTestFlag == 1) {
                                            compTestFlag = 1;
                                            if (values[0] == "STEP") {
                                                compTestFlagStart = 1;
                                            }
                                        }
                                        if (values[0] == "FunTest:" || functionFlag == 1) {
                                            functionFlag = 1;
                                            compTestFlag = 0;
                                            if (values[0] == "Step") {
                                                functionFlagStart = 1;
                                            }
                                        }
                                    });
                                    //把 result赋值给msg，并且输出
                                    result["custom"] = custom;
                                    result["boards"] = boards;
                                    result["detail"] = detail;
                                    result["newDetail"] = newDetail;
                                    msg.payload = result;
                                    node.send([null, null, null, msg]);
                                }


                            }
                        })

                    }


                    /*for all detail{
                        fs.readFile(item, function (err, data) {  //判断重复 判断csv结尾的格式
                            csvAll += data
                        })
                    }*/

                    //fs.readFile(csvAll, function (err, data) {

                    //});
                    //*******测试结果的数据分析结束**********
                }



            } catch (error) {
                node.error(error);
            }

        });
    }


    RED.nodes.registerType("fctdatahttp", fctdatahttpNode);
}

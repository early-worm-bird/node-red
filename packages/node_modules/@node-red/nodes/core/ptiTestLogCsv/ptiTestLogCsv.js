module.exports = function(RED) {
    function ptiTestLogCsvNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;

        node.on('input', async function(msg) {
            try {
                const filePath = msg.payload; // 获取输入消息中的文件路径

                if (!filePath || !filePath.endsWith('.csv')) {
                    node.error("无效的CSV文件路径");
                    return;
                }

                const fs = require('fs-extra');
                const iconv = require('iconv-lite');

                // 读取CSV文件内容
                const data = await fs.readFile(filePath);
                const text = iconv.decode(data, 'gb2312');

                // 初始化解析结果对象
                let datas = {
                    DateTime: "",
                    ProgramId: "",
                    User: "",
                    DeviceId: "",
                    FixtureId: "",
                    LineId: "",
                    ModelName: "",
                    FixRetry: "",
                    BoardId: "",
                    BarCode: "",
                    TestStat: "",
                    OpenTest: "",
                    ShortTest: "",
                    CompTest: "",
                    TestTime: "",
                    OpenFailCount: { "Count": 0, "Pins": [] },
                    ShortFailCount: { "Count": 0, "Pins": [] },
                    componentData: [],
                    functionData: []
                };

                // 解析CSV文件内容
                const resultLines = text.split('\n').map(line => line.trim().replaceAll('"', ""));
                let OpenFailCount = 0;
                let ShortFailCount = 0;
                let compTestFlag = 0;
                let compTestFlagStart = 0;
                let functionFlag = 0;
                let functionFlagStart = 0;

                for (let line of resultLines) {
                    const values = line.split(',');

                    if (values[0] == "DateTime") {
                        datas.DateTime = values[1];
                    }
                    if (values[0] == "ProgramId") {
                        datas.ProgramId = values[1];
                    }
                    if (values[0] == "User") {
                        datas.User = values[1];
                    }
                    if (values[0] == "DeviceId") {
                        datas.DeviceId = values[1];
                    }
                    if (values[0] == "FixtureId") {
                        datas.FixtureId = values[1];
                    }
                    if (values[0] == "LineId") {
                        datas.LineId = values[1];
                    }
                    if (values[0] == "ModelName") {
                        datas.ModelName = values[1];
                    }
                    if (values[0] == "FixRetry") {
                        datas.FixRetry = values[1];
                    }
                    if (values[0] == "BoardId") {
                        datas.BoardId = values[1];
                    }
                    if (values[0] == "BarCode") {
                        datas.BarCode = values[1];
                    }
                    if (values[0] == "TestStat") {
                        datas.TestStat = values[1];
                    }
                    if (values[0] == "OpenTest") {
                        datas.OpenTest = values[1];
                    }
                    if (values[0] == "ShortTest") {
                        datas.ShortTest = values[1];
                    }
                    if (values[0] == "CompTest") {
                        datas.CompTest = values[1];
                    }
                    if (values[0] == "TestTime") {
                        datas.TestTime = values[1];
                    }
                    if (OpenFailCount != 0) {
                        datas.OpenFailCount.Pins.push(values[0]);
                        OpenFailCount--;
                    }
                    if (values[0] == "OpenFailCount") {
                        datas.OpenFailCount.Count = parseInt(values[1], 10);
                        OpenFailCount = parseInt(values[1], 10);
                    }
                    if (ShortFailCount != 0) {
                        datas.ShortFailCount.Pins.push(values[0]);
                        ShortFailCount--;
                    }
                    if (values[0] == "ShortFailCount") {
                        datas.ShortFailCount.Count = parseInt(values[1], 10);
                        ShortFailCount = parseInt(values[1], 10);
                    }
                    if (compTestFlag == 1 && compTestFlagStart == 1 && values[0] !== "" && values[0] !== null) {
                        let stepCompData = {
                            STEP: values[0],
                            BX: values[1],
                            LC: values[2],
                            Flag: values[3],
                            Device: values[4],
                            STDval: values[5],
                            ACTval: values[6],
                            plusPercent: values[7],
                            minusPercent: values[8],
                            MD: values[9],
                            RG: values[10],
                            TM: values[11],
                            A: values[12],
                            B: values[13],
                            G1: values[14],
                            G2: values[15],
                            G3: values[16],
                            G4: values[17],
                            G5: values[18],
                            TestVal: values[19],
                            DevPercent: values[20],
                            Result: values[21],
                        };
                        datas.componentData.push(stepCompData);
                    }
                    if (functionFlag == 1 && functionFlagStart == 1 && values[0] !== "" && values[0] !== null) {
                        let stepFunctionData = {
                            STEP: values[0],
                            BX: values[1],
                            Descrip: values[2],
                            Module: values[3],
                            Type: values[4],
                            Function: values[5],
                            Delay: values[6],
                            Test: values[7],
                            DevPercent: values[8],
                            Std: values[9],
                            minusPercent: values[10],
                            plusPercent: values[11],
                            Result: values[12],
                            Info: values[13],
                        };
                        datas.functionData.push(stepFunctionData);
                    }
                    if (values[0] == "CompTest:" || compTestFlag == 1) {
                        compTestFlag = 1;
                        if (values[0] == "STEP") {
                            compTestFlagStart = 1;
                        }
                    }
                    if (values[0] == "FunTest:" || functionFlag == 1) {
                        functionFlag = 1;
                        compTestFlag = 0;
                        if (values[0] == "Step") {
                            functionFlagStart = 1;
                        }
                    }
                    if (values[0] == "LogEnd") {
                        break;
                    }
                }

                // 将解析后的数据设置为消息的有效载荷，并发送出去
                msg.payload = datas;
                node.send(msg);
            } catch (error) {
                node.error(error);
            }
        });
    }

    RED.nodes.registerType("ptiTestLogCsv", ptiTestLogCsvNode);
}